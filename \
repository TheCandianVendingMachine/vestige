#include <stdlib.h>
#include <math.h>

#include "engine.h"
#include "logger.h"
#include "game/game_states.h"
#include "game/physics_test.h"

Vector2f GRAVITY = (Vector2f) { .x = 0.f, .y = 9.81f };

void simulate_body(RigidBody* body, float delta_time) {
    //body->acceleration = add_vector2f(body->acceleration, GRAVITY);
    rigid_body_step(body, delta_time);
}

void collide_bodies(RigidBody* b0, RigidBody* b1) {
    b0->bounds.position = b0->position;
    b1->bounds.position = b1->position;
    if (!aabb_intersect(b0->bounds, b1->bounds)) {
        return;
    }

    // conserve energy and momentum in a collision
    float inverse_mass_sum = 2.f / (b0->mass + b1->mass);
    float distance_sqr = length2_vector2f(sub_vector2f(b0->position, b1->position));

    float dvdp_dot_1 = dot_vector2f(sub_vector2f(b0->velocity, b1->velocity), sub_vector2f(b0->position, b1->position));
    float dvdp_dot_2 = dot_vector2f(sub_vector2f(b1->velocity, b0->velocity), sub_vector2f(b1->position, b0->position));

    {
        float m = b1->mass * inverse_mass_sum * dvdp_dot_1 / distance_sqr;
        b0->velocity = sub_vector2f(b0->velocity, mul_vector2f(sub_vector2f(b0->position, b1->position), m));
    }

    {
        float m = b0->mass * inverse_mass_sum * dvdp_dot_2 / distance_sqr;
        b1->velocity = sub_vector2f(b1->velocity, mul_vector2f(sub_vector2f(b1->position, b0->position), m));
    }

    // Calculate normal force
    Vector2f b0_origin = add_vector2f(b0->bounds.position, mul_vector2f(b0->bounds.size, 0.5f));
    Vector2f b1_origin = add_vector2f(b1->bounds.position, mul_vector2f(b1->bounds.size, 0.5f));

    Vector2f dir = sub_vector2f(b1_origin, b0_origin);
    dir = mul_vector2f(dir, 0.5f);

    b0->position = sub_vector2f(b0->position, dir);
    b1->position = sub_vector2f(b1->position, mul_vector2f(dir, -1.f));

}

void physics_push(struct GameState* state) {
    state->stored_state = malloc(sizeof(PhysicsTestState));

    PhysicsTestState* s = (PhysicsTestState*)state->stored_state;
    s->projection = matrix_orthographic_projection(
        0.f, -1.f * ENGINE->window.size.x,
        0.f, ENGINE->window.size.y,
        -1.f, 1.f
    );
    s->camera = new_camera();

    s->renderer = new_debug_renderer();

    s->floor = (Floor) {
        .body = create_rigid_body()
    };
    s->floor.body.bounds = (AABB) {
        .position = (Vector2f) { .x = 0.f, .y = 0.f },
        .size = (Vector2f) {
            .x = 1000.f,
            .y = 50.f
        }
    };
    s->floor.body.position = (Vector2f) {
        .x = ENGINE->window.size.x / 2.f,
        .y = ENGINE->window.size.y - 20.f - s->floor.body.bounds.size.y
    };
    s->floor.body.mass = INFINITY;

    s->rectangles = VECTOR(Rectangle);

    Rectangle r = (Rectangle) {
        .body = create_rigid_body()
    };
    r.body.bounds = (AABB) {
        .position = (Vector2f) { .x = 0.f, .y = 0.f },
        .size = (Vector2f) {
            .x = 120.f,
            .y = 120.f
        }
    };
    r.body.position = (Vector2f) {
        .x = 0.f,
        .y = 200.f
    };
    r.body.velocity.x = 50.f;
    r.body.velocity.y = 1.f;
    r.body.mass = 10.f;

    VECTOR_PUSH(Rectangle, &s->rectangles, r);

    r.body.position = (Vector2f) {
        .x = 1280.f - 60.f,
        .y = 200.f
    };
    r.body.velocity.x = -50.f;
    r.body.velocity.y = -1.f;
    r.body.mass = 10.f;

    VECTOR_PUSH(Rectangle, &s->rectangles, r);
}

void physics_pop(struct GameState* state) {
    PhysicsTestState* s = (PhysicsTestState*)state->stored_state;

    free(s);
}

void physics_update(struct GameState* state) {
    //PhysicsTestState* s = (PhysicsTestState*)state->stored_state;
}

void physics_fixed_update(struct GameState* state, float delta_time) {
    PhysicsTestState* s = (PhysicsTestState*)state->stored_state;
    for (int i = 0; i < s->rectangles.length; i++) {
        Rectangle *r = &_VECTOR_GET(Rectangle, &s->rectangles, i);
        simulate_body(&r->body, delta_time);
    }

    collide_bodies(&((Rectangle*)s->rectangles.buffer)[0].body, &((Rectangle*)s->rectangles.buffer)[1].body);

    collide_bodies(&((Rectangle*)s->rectangles.buffer)[0].body, &s->floor.body);
    collide_bodies(&((Rectangle*)s->rectangles.buffer)[1].body, &s->floor.body);
}

void physics_render(struct GameState* state) {
    PhysicsTestState* s = (PhysicsTestState*)state->stored_state;

    for (int i = 0; i < s->rectangles.length; i++) {
        Rectangle r = _VECTOR_GET(Rectangle, &s->rectangles, i);
        debug_rectangle(&s->renderer, (DebugShapeRectangle) {
            .position = r.body.position,
            .colour = hex_to_rgb("0xAA0000"),
            .dimensions = r.body.bounds.size,
            .thickness = 1.f
        });
    }

    debug_rectangle(&s->renderer, (DebugShapeRectangle) {
        .position = s->floor.body.position,
        .colour = hex_to_rgb("0xFFFFFF"),
        .dimensions = s->floor.body.bounds.size,
        .thickness = 1.f
    });

    draw_debug(&s->renderer, s->camera, s->projection);
}

